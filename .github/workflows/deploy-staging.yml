name: Deploy to Staging

on:
  push:
    branches:
      - staging
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (not recommended)'
        required: false
        default: 'false'

jobs:
  # Quick validation before deployment
  validate:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Quick validation
      run: |
        echo "ğŸ” Quick validation before deployment..."
        cd server && node -c index.js && echo "âœ… Server syntax OK"
        cd ../client && npm run build && echo "âœ… Client build OK"
      continue-on-error: false

  deploy-staging:
    needs: validate
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: package-lock.json
        
    - name: Install dependencies
      run: |
        npm install
        cd client && npm install && cd ..
        cd server && npm install && cd ..
        
    - name: Build client
      run: |
        cd client
        npm run build
        
    - name: Create deployment package
      run: |
        mkdir -p deploy
        cp -r server deploy/
        cp -r client/build deploy/client-build
        cp package.json deploy/
        cp -r .github/scripts deploy/scripts || true
        # Ensure ecosystem.config.js is included
        if [ -f server/ecosystem.config.js ]; then
          cp server/ecosystem.config.js deploy/server/
        fi
        # Copy nginx config for staging
        mkdir -p deploy/nginx
        if [ -f nginx/manufacturing-app-staging.conf ]; then
          cp nginx/manufacturing-app-staging.conf deploy/nginx/
        fi
        tar -czf deploy.tar.gz deploy/
        
    - name: Deploy to Staging VPS
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        source: "deploy.tar.gz"
        target: "/home/${{ secrets.VPS_USER }}/deployments"
        
    - name: Execute staging deployment script on VPS
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        script: |
          set -e
          
          STAGING_DIR="/home/${{ secrets.VPS_USER }}/deployments/manufacturing-app-staging"
          STAGING_PORT=3467
          STAGING_DB_NAME="Staging_Manufacturing_Order"
          DB_USER="admin"
          DB_PASSWORD="Admin123"
          DB_PORT=5433
          
          echo "ğŸš€ Starting STAGING deployment..."
          echo "ğŸ“ Staging directory: $STAGING_DIR"
          echo "ğŸ“ Staging port: $STAGING_PORT"
          echo "ğŸ“ Staging database: $STAGING_DB_NAME"
          
          cd /home/${{ secrets.VPS_USER }}/deployments
          tar -xzf deploy.tar.gz
          
          # Verify extracted files
          echo "ğŸ“‹ Checking extracted files..."
          ls -la deploy/ || echo "âš ï¸  Deploy directory check"
          ls -la deploy/server/ || echo "âš ï¸  Server directory check"
          
          # Backup existing staging deployment
          if [ -d "$STAGING_DIR" ]; then
            echo "ğŸ“¦ Creating staging backup..."
            mv "$STAGING_DIR" "${STAGING_DIR}-backup-$(date +%Y%m%d-%H%M%S)"
          fi
          
          # Create new staging deployment directory
          echo "ğŸ“ Creating staging directory..."
          mkdir -p "$STAGING_DIR"
          mv deploy/* "$STAGING_DIR/"
          
          # Verify files moved correctly
          echo "ğŸ“‹ Verifying deployment files..."
          if [ ! -d "$STAGING_DIR/server" ]; then
            echo "âŒ ERROR: Server directory not found in $STAGING_DIR"
            ls -la "$STAGING_DIR/"
            exit 1
          fi
          
          if [ ! -f "$STAGING_DIR/server/index.js" ]; then
            echo "âŒ ERROR: index.js not found in $STAGING_DIR/server"
            ls -la "$STAGING_DIR/server/"
            exit 1
          fi
          
          # Verify client-build exists
          if [ ! -d "$STAGING_DIR/client-build" ]; then
            echo "âŒ ERROR: client-build directory not found in $STAGING_DIR"
            ls -la "$STAGING_DIR/"
            exit 1
          fi
          
          if [ ! -f "$STAGING_DIR/client-build/index.html" ]; then
            echo "âŒ ERROR: index.html not found in $STAGING_DIR/client-build"
            ls -la "$STAGING_DIR/client-build/" | head -10
            exit 1
          fi
          
          echo "âœ… Client build verified: $(ls -1 $STAGING_DIR/client-build | wc -l) files"
          
          # Setup staging database
          echo "ğŸ—„ï¸  Setting up staging database..."
          export PGPASSWORD="$DB_PASSWORD"
          
          # Check if database exists
          DB_EXISTS=$(psql -h localhost -p $DB_PORT -U "$DB_USER" -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = '$STAGING_DB_NAME'" | grep -q 1 && echo "yes" || echo "no")
          
          if [ "$DB_EXISTS" = "no" ]; then
            # Create database if it doesn't exist
            echo "   ğŸ“‹ Creating database $STAGING_DB_NAME..."
            # Try with admin user first, fallback to superuser if needed
            if ! psql -h localhost -p $DB_PORT -U "$DB_USER" -d postgres -c "CREATE DATABASE \"$STAGING_DB_NAME\";" 2>/dev/null; then
              echo "   âš ï¸  User $DB_USER doesn't have permission to create database"
              echo "   ğŸ“‹ Using superuser (postgres) to create database..."
              sudo -u postgres psql -h localhost -p $DB_PORT -d postgres -c "CREATE DATABASE \"$STAGING_DB_NAME\";"
            fi
            echo "   âœ… Database $STAGING_DB_NAME created"
          else
            echo "   âœ… Database $STAGING_DB_NAME already exists"
          fi
          
          # Grant privileges to admin user
          echo "   ğŸ” Granting privileges to user $DB_USER..."
          # Try with admin user first, fallback to superuser if needed
          if ! psql -h localhost -p $DB_PORT -U "$DB_USER" -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$STAGING_DB_NAME\" TO \"$DB_USER\";" 2>/dev/null; then
            echo "   âš ï¸  Using superuser to grant privileges..."
            sudo -u postgres psql -h localhost -p $DB_PORT -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"$STAGING_DB_NAME\" TO \"$DB_USER\";"
          fi
          
          # Connect to the database and grant schema privileges
          echo "   ğŸ” Granting schema privileges..."
          psql -h localhost -p $DB_PORT -U "$DB_USER" -d "$STAGING_DB_NAME" -c "GRANT ALL ON SCHEMA public TO \"$DB_USER\";" || \
          sudo -u postgres psql -h localhost -p $DB_PORT -d "$STAGING_DB_NAME" -c "GRANT ALL ON SCHEMA public TO \"$DB_USER\";"
          
          psql -h localhost -p $DB_PORT -U "$DB_USER" -d "$STAGING_DB_NAME" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO \"$DB_USER\";" || \
          sudo -u postgres psql -h localhost -p $DB_PORT -d "$STAGING_DB_NAME" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO \"$DB_USER\";"
          
          psql -h localhost -p $DB_PORT -U "$DB_USER" -d "$STAGING_DB_NAME" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO \"$DB_USER\";" || \
          sudo -u postgres psql -h localhost -p $DB_PORT -d "$STAGING_DB_NAME" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO \"$DB_USER\";"
          
          echo "âœ… Database setup completed"
          unset PGPASSWORD
          
          # Install/update dependencies
          echo "ğŸ“¦ Installing staging dependencies..."
          cd "$STAGING_DIR/server"
          npm install --production
          
          # Create staging .env if it doesn't exist
          if [ ! -f .env ]; then
            echo "ğŸ“ Creating staging .env file..."
            echo "NODE_ENV=staging" > .env
            echo "PORT=$STAGING_PORT" >> .env
            echo "DB_HOST=localhost" >> .env
            echo "DB_PORT=$DB_PORT" >> .env
            echo "DB_NAME=$STAGING_DB_NAME" >> .env
            echo "DB_USER=$DB_USER" >> .env
            echo "DB_PASSWORD=$DB_PASSWORD" >> .env
          else
            # Ensure PORT is set to staging port
            if grep -q "^PORT=" .env; then
              sed -i "s/^PORT=.*/PORT=$STAGING_PORT/" .env
            else
              echo "PORT=$STAGING_PORT" >> .env
            fi
            # Ensure NODE_ENV is staging
            if grep -q "^NODE_ENV=" .env; then
              sed -i "s/^NODE_ENV=.*/NODE_ENV=staging/" .env
            else
              echo "NODE_ENV=staging" >> .env
            fi
            # Ensure DB_NAME is set to staging database
            if grep -q "^DB_NAME=" .env; then
              sed -i "s/^DB_NAME=.*/DB_NAME=$STAGING_DB_NAME/" .env
            else
              echo "DB_NAME=$STAGING_DB_NAME" >> .env
            fi
            # Ensure DB_USER is admin
            if grep -q "^DB_USER=" .env; then
              sed -i "s/^DB_USER=.*/DB_USER=$DB_USER/" .env
            else
              echo "DB_USER=$DB_USER" >> .env
            fi
            # Ensure DB_PASSWORD is set
            if grep -q "^DB_PASSWORD=" .env; then
              sed -i "s/^DB_PASSWORD=.*/DB_PASSWORD=$DB_PASSWORD/" .env
            else
              echo "DB_PASSWORD=$DB_PASSWORD" >> .env
            fi
            # Ensure DB_PORT is 5433
            if grep -q "^DB_PORT=" .env; then
              sed -i "s/^DB_PORT=.*/DB_PORT=$DB_PORT/" .env
            else
              echo "DB_PORT=$DB_PORT" >> .env
            fi
          fi
          
          # Verify .env file
          echo "ğŸ“ Verifying .env file..."
          cat .env
          
          # Create logs directory
          mkdir -p logs
          
          # Restart staging application with PM2
          echo "ğŸ”„ Restarting staging application with PM2..."
          cd "$STAGING_DIR/server"
          
          # Delete existing process if exists
          pm2 delete manufacturing-app-staging 2>/dev/null || echo "No existing staging process to delete"
          
          # Verify current directory and files
          echo "ğŸ“‹ Current directory: $(pwd)"
          echo "ğŸ“‹ Files in server directory:"
          ls -la
          
          # Start application with PM2
          echo "ğŸš€ Starting application..."
          if [ -f ecosystem.config.js ]; then
            echo "ğŸ“‹ Using ecosystem.config.js (staging config)"
            # Use --only to start only the staging app from ecosystem file
            pm2 start ecosystem.config.js --only manufacturing-app-staging --update-env
          else
            echo "ğŸ“‹ Using direct start with index.js"
            pm2 start index.js --name manufacturing-app-staging --instances 1 --cwd "$STAGING_DIR/server" --env NODE_ENV=staging --env PORT=$STAGING_PORT
          fi
          
          # Verify PM2 process started
          echo "â³ Waiting 2 seconds for PM2 to register process..."
          sleep 2
          
          echo "ğŸ“Š PM2 Status:"
          pm2 status
          
          # Check if process is running
          if pm2 list | grep -q "manufacturing-app-staging"; then
            echo "âœ… PM2 process 'manufacturing-app-staging' is registered"
          else
            echo "âŒ ERROR: PM2 process 'manufacturing-app-staging' NOT found!"
            echo "ğŸ“‹ PM2 list output:"
            pm2 list
            echo "ğŸ“‹ PM2 logs:"
            pm2 logs manufacturing-app-staging --lines 20 --nostream || true
            exit 1
          fi
          
          pm2 save
          echo "âœ… PM2 process saved"
          
          # Wait a bit for app to start
          sleep 5
          
          # Health check
          echo "ğŸ¥ Checking staging health..."
          HEALTH_CHECK=$(curl -s http://localhost:$STAGING_PORT/health || echo "failed")
          if echo "$HEALTH_CHECK" | grep -q "healthy"; then
            echo "âœ… Staging health check passed!"
          else
            echo "âš ï¸  Staging health check failed, but continuing..."
            echo "Response: $HEALTH_CHECK"
          fi
          
          # Setup nginx config for staging
          echo "ğŸ“ Setting up nginx config for staging..."
          NGINX_CONF_SOURCE=""
          NGINX_CONF_AVAILABLE="/etc/nginx/sites-available/manufacturing-app-staging.conf"
          NGINX_CONF_ENABLED="/etc/nginx/sites-enabled/manufacturing-app-staging.conf"
          
          # Try to find nginx config - check deployment package first
          if [ -f "$STAGING_DIR/nginx/manufacturing-app-staging.conf" ]; then
            NGINX_CONF_SOURCE="$STAGING_DIR/nginx/manufacturing-app-staging.conf"
            echo "   âœ… Found nginx config in deployment package"
          elif [ -f "/home/${{ secrets.VPS_USER }}/deployments/nginx/manufacturing-app-staging.conf" ]; then
            NGINX_CONF_SOURCE="/home/${{ secrets.VPS_USER }}/deployments/nginx/manufacturing-app-staging.conf"
            echo "   âœ… Found nginx config in deployments/nginx"
          elif [ -f "/home/${{ secrets.VPS_USER }}/nginx/manufacturing-app-staging.conf" ]; then
            NGINX_CONF_SOURCE="/home/${{ secrets.VPS_USER }}/nginx/manufacturing-app-staging.conf"
            echo "   âœ… Found nginx config in user nginx directory"
          else
            echo "   âš ï¸  Nginx config not found, skipping nginx setup"
            echo "   ğŸ’¡ Please setup manually: cp nginx/manufacturing-app-staging.conf /etc/nginx/sites-available/"
          fi
          
          if [ -n "$NGINX_CONF_SOURCE" ] && [ -f "$NGINX_CONF_SOURCE" ]; then
            # Copy nginx config
            echo "   ğŸ“‹ Copying nginx config from: $NGINX_CONF_SOURCE"
            sudo cp "$NGINX_CONF_SOURCE" "$NGINX_CONF_AVAILABLE"
            echo "   âœ… Nginx config copied to $NGINX_CONF_AVAILABLE"
            
            # Verify config doesn't have default_server (for isolation)
            if grep -q "default_server" "$NGINX_CONF_AVAILABLE"; then
              echo "   âš ï¸  WARNING: Config contains 'default_server' - removing for isolation"
              sudo sed -i 's/listen 80 default_server/listen 80/g' "$NGINX_CONF_AVAILABLE"
              sudo sed -i 's/listen \[::\]:80 default_server/listen [::]:80/g' "$NGINX_CONF_AVAILABLE"
            fi
            
            # Enable config
            if [ ! -L "$NGINX_CONF_ENABLED" ] && [ ! -f "$NGINX_CONF_ENABLED" ]; then
              sudo ln -s "$NGINX_CONF_AVAILABLE" "$NGINX_CONF_ENABLED"
              echo "   âœ… Nginx config enabled"
            fi
            
            # Test and reload nginx
            echo "   ğŸ§ª Testing nginx configuration..."
            if sudo nginx -t 2>&1 | grep -q "successful"; then
              echo "   âœ… Nginx config test passed"
              sudo systemctl reload nginx
              echo "   âœ… Nginx reloaded successfully"
              # Verify nginx is running
              sudo systemctl status nginx --no-pager -l | head -5
            else
              echo "   âŒ Nginx config test failed!"
              sudo nginx -t
              echo "   âš ï¸  Nginx not reloaded - please fix config manually"
            fi
          fi
          
          # Cleanup old staging backups (keep last 3)
          echo "ğŸ§¹ Cleaning up old staging backups..."
          cd /home/${{ secrets.VPS_USER }}/deployments
          ls -dt manufacturing-app-staging-backup-* 2>/dev/null | tail -n +4 | xargs rm -rf || true
          
          # Cleanup
          rm -f deploy.tar.gz
          
          echo "âœ… Staging deployment completed!"
          echo "ğŸ“ Staging app running on port: $STAGING_PORT"
          echo "ğŸ“ Database: $STAGING_DB_NAME"
          pm2 status | grep manufacturing-app-staging || echo "âš ï¸  Check PM2 status manually"
